---
author: mscolas
layout: post
title: L'injection de dépendance au build
date: 2019-10-25 07:00:00
image: '/images/go/go-wire.png'
description: go propose une manière bien à elle de fournir un système d'injection de dépendance
category: 'documentation'
tags:
- go
- injection de dépendance
- wire
introduction: L'injection de dépendance au build
---

# Wire pour créer l'injection de dépendance pendant le build

Le langage go [gagne de la popularité d'année en année.](https://www.benfrederickson.com/ranking-programming-languages-by-github-users/). Avec sa volonté d'être simple, performant et scalable, la communauté de développeur s'intéresse à ce language moderne made in google.

Pour s'aider dans le principe d'Inversion of Controls, Go a deux librairies populaires qui remplissent le même objectif par le même moyen: construire un container et le résoudre pendant le runtime. Voyez vous même [inject de Facebook](https://github.com/facebookarchive/inject) ou bien [dig](https://github.com/uber-go/dig).

Google cloud propose une autre solution pour définir le graph d'injection de dépenance. L'inversion des controls se fait pendant ou avant le build. Voici Wire en action.

## Un article court

L'objectif de cette publication est de montrer une alternative aux méthodes habituelles d'injection de dépendances.. Nous n'explorerons pas la librairie Wire en profondeur. Si vous voulez avoir des exemples plus poussées de cette librairie, n'hésitez pas à le demander en commentaire.

## Un exemple simple

Débutons par un exemple simple qui nous servira d'exposer avantages de cette solution.

```go
type TodoRepository interface {
    Save(todo Todo) error
    Get(todoName string) (Todo, error)
}

type TodoFileRepository struct {

}

func NewTodoRepository() TodoRepository {
    return TodoFileRepository{}
}



func (repo TodoFileRepository) Save(todo Todo) error {
    // [...]
}

func (repo TodoFileRepository) Get(todoName string) (Todo, error) {
    // [...]
}

// ...

type TodoService struct {
    repository TodoRepository
}

func NewTodoService(repo TodoRepository) TodoService {
    return TodoService{repository: repo}
}
```

Rien d'extraordinaire, 2 types contenant ses dépendances simples. Et chacun son _constructeur_.

## Wire fait son entrée

Nous installons la librairie wire via la commande `go get github.com/google/wire/cmd/wire`. Ceci installera une application cli pour créer notre injection de dépendance avant le build.

Si vous rencontrez des problèmes d'installation, je vous redirige vers [le github officiel](https://github.com/google/wire).

### implémentation du wire build

Dans le même package, ajoutez un ficiher `wire.go` avec ceci:

```go
//+build wireinject

package main

import (
    "github.com/google/wire"
)

func BuildTodoService() TodoService {
    wire.Build(NewTodoRepository, NewTodoService)
    return TodoService{}
}
```

Executez la commande `wire`. Un nouveau fichier est créé.Observons le contenu:

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

// Injectors from wire.go:

func BuildTodoService() TodoService {
    todoRepository := NewTodoRepository()
    todoService := NewTodoService(todoRepository)
    return todoService
}
```

Magnifique ! Ce nouveau fichier contient toute la logique pour créer un TodoService avec l'arbre de dépendance en entier.

## Pourquoi une autre manière d'injecter les dépendances ?

Selon les [avantages avancées par Google](https://blog.golang.org/wire), nous recevons:

* Facilité le debug car le code est straight-forward. Débugguer de la résolution de dépendance évalué au run-time sont parfois complexe à suivre.
* Utilise les types pour évaluer les résolutions.
* Appelle le strict nécessaire. Voyez-ceci comme un tree-shaking
* Ajoute de la clairté dans le code. Ceci permet à certains outils de manier le code.

Personnellement, cette solution élégante pour les raisons suivantes:

* Nous conservons la facilité d'écrire des nouvelles injections avec peu de code. Pour chaque nouvelles dépendances, peu de nouveau code est nécessaire.
* Le résultat a une lecture fabuleuse. La méthode générée contient tout le nécessaire pour connaitre toutes les dépendances.
* L'évolution des dépendances est lisible à travers le temps. Regardez l'historique git du fichier généré et vous aurez toutes les informations nécessaires à vos besoins sans devoir compiler et executer.

### Un peu plus sur la librairie

L'exemple ci-dessus est volontairement léger. Beaucoup d'autres outils intégré à wire permet de gérer différents problèmes récurrents. J'utilise les Sets et Values, je vous invite à lire la documentation officielle.

Retrouvez le code de l'article [ici](https://github.com/worming004/todowireblog).

---

<div class="gratitude">
    <span>MERCI</span>
    <p>d'avoir pris le temps de lire cet article</p>
</div>

---

<div id="toc"></div>
**Table des matières**
1. TOC
{:toc}
